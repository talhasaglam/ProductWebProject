<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.RdCore</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Collections.CollectionEx">
            <summary>
            Extension methods for collections
            </summary>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.ContentHashCode``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Calculates polynomial hash code for collection.
            Return 0 if collection == null.
            Return `seed` (in current implementation 0x2D2816FE) if collection is empty.
            In current implementation polynomial factor is 31.
            </summary>
            <param name="collection"></param>
            <typeparam name="T"></typeparam>
            <returns>((seed * factor + collection[0]?.GetHashCode() ?? 0) * factor + collection[1]?.GetHashCode() ?? 0) * factor + ... </returns>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.TryDequeue``1(System.Collections.Generic.Queue{``0},``0@)">
            <summary>
            Dequeue <paramref name="queue"/> if it's not empty (or do nothing).
            </summary>
            <param name="queue"></param>
            <param name="res"><see cref="M:System.Collections.Generic.Queue`1.Dequeue"/> if <paramref name="queue"/>.Count > 0 at method start, `default{T}` otherwise</param>
            <typeparam name="T"></typeparam>
            <returns>`true` if <paramref name="queue"/>.Count > 0 at method start, `false` otherwise</returns>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.Enqueued``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>
            Same as <see cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)"/> but returns added element
            </summary>
            <param name="queue"></param>
            <param name="toEnqueue">Element to enqueue into <paramref name="queue"/></param>
            <typeparam name="T"></typeparam>
            <returns>Added element <paramref name="toEnqueue"/></returns>
        </member>
        <member name="T:JetBrains.Collections.EmptyEnumerator`1">
            <summary>
            Enumerator for empty collection.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.JetKeyValuePair">
            <summary>
            Facilitates <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            </summary>
        </member>
        <member name="T:JetBrains.Collections.IPriorityQueue`1">
            <summary>
            JetBrains interface of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.JetPriorityQueue`1">
            <summary>
            JetBrains implementation of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.BlockingPriorityQueue`1">
            <summary>
            Thread-safe implementation of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.ExtractOrBlock">
            <summary>
            Returns first element from queue or waits until it appears. In case of lifetime termination throws PCE.
            </summary>
            <returns>First element in queue</returns>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.Enqueue(`0)">
            <summary>
            Enqueues an item and returns the total number of items in the queue right after enqueueing, in a thread-safe-consistent manner.
            </summary>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.ToArray">
            <summary>
            Copies data to an array, thread-safely.
            </summary>
        </member>
        <member name="M:JetBrains.Collections.PriorityQueueEx.Enqueue``1(JetBrains.Collections.IPriorityQueue{``0},``0)">
            <summary>
            Same as <see cref="!:IPriorityQueue&lt;T&gt;.Add"/>
            </summary>
            <param name="queue"></param>
            <param name="val"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.ReferenceEqualityComparer`1">
            <summary>
            Comparer that uses reference equality.
            Usage: `ReferenceEqualityComparer{T}.Default`
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedDictionary`2">
            <summary>
            This dictionary is used for Net3.5 as a poor replacement of ConcurrentDictionary.
            All methods are synchronized. <see cref="M:JetBrains.Collections.Synchronized.SynchronizedDictionary`2.GetEnumerator"/> copies whole content so
            you can change collection as you want during enumeration. 
            </summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="TV"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedList`1">
            <summary>
            This is a thread-safe list with all methods synchronized.
            <see cref="M:JetBrains.Collections.Synchronized.SynchronizedList`1.GetEnumerator"/> copies whole content so
            you can change collection as you want during enumeration. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedSet`1">
             <summary>
             This is a thread-safe set with all methods synchronized.
             <see cref="M:JetBrains.Collections.Synchronized.SynchronizedSet`1.GetEnumerator"/> copies whole content so
             you can change collection as you want during enumeration.
            
             Useful pattern (in place filtering):
             <code>
               using (en = syncSet.GetEnumerator()) {
                 while (en.MoveNext()) {
                   if (some_condition(en.Current))
                     syncSet.Remove(en.Current);
                 }
               }
             </code>
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Viewable.AddUpdateRemove">
            <summary>
            Defines whether the event kind is <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Add"/>, <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Update"/> or <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Remove"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Collections.Viewable.AddRemove">
            <summary>
            Defines whether the event kind is <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> or <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Collections.SingletonEnumerator`1">
            <summary>
            Enumerator for imaginary collection from single value
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.CompactList`1">
            <summary>
            Saves memory footprint and traffic for lists with single element: doesn't allocate real list
            until number of elements is more than 1.
            <see cref="M:JetBrains.Collections.CompactList`1.GetEnumerator"/> return struct that should save memory traffic during enumeration.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Util.EmptyArray`1">
            <summary>
            Reuses the single instance of an empty array (one per type). If possible, prefer <code>EmptyList{T}.InstanceList</code>
            because each time you enumerate empty array, new <code>Array.SZArrayEnumerator</code> class instance is being created.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyArray">
            <summary>
            Reuses the single instance of an empty array (one per type).
            </summary>
        </member>
        <member name="M:JetBrains.Util.EmptyArray.GetInstance``1">
            <summary>Synonym for <see cref="F:JetBrains.Util.EmptyArray`1.Instance"/></summary>
        </member>
        <member name="T:JetBrains.Util.BitHacks">
            <summary>
            Inspired by http://graphics.stanford.edu/~seander/bithacks.html
            </summary>
        </member>
        <member name="M:JetBrains.Util.BitHacks.Log2Floor(System.Int32)">
            <summary>
            Returns largest non-negative integer <c>y</c> such that <c>2^y&lt;=x</c> if <c>x&gt;0</c>, <c>0</c> if <c>x=0</c>, or throw ArgumentException if <c>x&lt;0</c> 
            </summary>
            <param name="x">Must be greater than or equal to zero.</param>
            <returns><c>y : 2^y&lt;=x</c></returns>
        </member>
        <member name="M:JetBrains.Util.BitHacks.Log2Ceil(System.Int64)">
            <summary>
            Returns lowest non-negative integer <c>y</c> such that <c>2^y&gt;=x</c> if <c>x&gt;=0</c> or throw ArgumentException if <c>x&lt;0</c> 
            </summary>
            <param name="x">Must be greater than or equal to zero.</param>    
            <returns><c>y : 2^y&gt;=x</c></returns>    
        </member>
        <member name="M:JetBrains.Util.BitHacks.NumberOfBitSet(System.Int32)">
            <summary>
            Return number of <c>1</c>-s in binary representation of <c>x</c>
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Util.CastTo`1">
            <summary>
            !!! Use it with caution. Main purpose is enum to/from int casting without boxing !!!
            /// https://stackoverflow.com/questions/1189144/c-sharp-non-boxing-conversion-of-generic-enum-to-int/23391746#23391746
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.CastTo`1.From``1(``0)">
            <summary>    
            Casts <see cref="!:TFrom"/> to TTo  without boxing for value types. Useful in generic methods.    
            </summary>
            <typeparam name="TFrom">Source type to cast from. Usually a generic type.</typeparam>
        </member>
        <member name="T:JetBrains.Util.Util.Statics">
            <summary>
            Represents global statics in a stack-like way 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Statics.For``1">
            <summary>
            Gets statics holder for type <see cref="!:T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns>Stack-like holder</returns>
        </member>
        <member name="T:JetBrains.Util.Util.Types">
            <summary>
            Extensions to <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Util.Types.ourPrimitives">
            <summary>
            To prettify Int32, Int64 and so on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Types.ToString(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Different <c>ToString()</c> of <see cref="T:System.Type"/>.
            
            Samples are provide for:  
            <code>
            namespace Foo { 
              class Outer&lt;T1&gt;
              {
                 internal class Inner&lt;T2&gt; {}
              }    
            }
            
            </code>     
            </summary>
            <param name="thisType"><c>typeof(Outer&lt;string&gt;.Inner&lt;int&gt;)</c></param>
            <param name="withNamespaces">if `true` (and <see cref="!:withGenericArguments"/> == `false`) then <c>Foo.Outer+Inner</c> else <c>Outer+Inner</c> </param>
            <param name="withGenericArguments">if `true` (and <see cref="!:withNamespaces"/> == `false`) then <c>Outer&lt;string&gt;+Inner&lt;int&gt;</c> else <c>Outer+Inner</c> </param>
            <returns>More natural than <see cref="M:System.Type.ToString"/> string representation of type</returns>
        </member>
        <member name="F:JetBrains.Util.MethodImplAdvancedOptions.AggressiveInlining">
            <summary>
            Corresponds to <code>MethodImplOptions.AggressiveInlining</code> value in 4.5 framework. This value is just swallowed in lower frameworks
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetSetter(System.Reflection.MemberInfo)">
            <summary>
            Return setter for either field or property info
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.TryGetSetter(System.Reflection.MemberInfo)">
            <summary>
            Return setter for either field or property info, or null if can't be set.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetGetter(System.Reflection.MemberInfo)">
            <summary>
            Return getter for either field or property
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetReturnType(System.Reflection.MemberInfo)">
            <summary>
            Get field or property type.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetPropertyValueSafe``1(System.Object,System.String,``0)">
            <summary>
            Evaluates property value available on object or any of the interfaces it implements
            </summary>
            <param name="o">Object to invoke property of</param>
            <param name="propertyName">Name of the property</param>
            <param name="defaultValue">Default value to return if failed</param>
            <typeparam name="T">Expected return type</typeparam>
            <returns>Evaluated property value or default value</returns>
        </member>
        <member name="T:JetBrains.Core.Maybe`1">
            <summary>
            Implementation of 'maybe' monad.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Core.Nothing">
            <summary>
            Type that has no instances. Subclass of all classes, so can be casted to any class.
            </summary>
        </member>
        <member name="M:JetBrains.Core.Nothing.As``1">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as a return value for unreachable code.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>always fail</returns>
        </member>
        <member name="M:JetBrains.Core.Nothing.Unreachable``1">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as a return value for unreachable code.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>always fail</returns>
        </member>
        <member name="M:JetBrains.Core.Nothing.Unreachable">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as an assertion in unreachable code.
            </summary>
            <returns>always fail</returns>
        </member>
        <member name="T:JetBrains.Core.Result">
            <summary>
            Helper methods for <see cref="T:JetBrains.Core.Result`1" /> and <see cref="T:JetBrains.Core.Result`2"/> building
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result.EmptyFailMessage">
            <summary>
            Message that is being applied to Result.Fail when no message provided 
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result.Success``1(``0)">
            <summary>
            Creates successful <see cref="T:JetBrains.Core.Result`1"/> with value <see cref="!:value"/>
            </summary>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == true</returns>
        </member>
        <member name="M:JetBrains.Core.Result.Fail(System.Exception,System.Boolean)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/>
            </summary>
            <param name="exception"></param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/> </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="M:JetBrains.Core.Result.Fail``1(System.Exception,``0,System.Boolean)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`2"/> with corresponding <see cref="!:failValue"/>
            </summary>
            <param name="exception"></param>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/> </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`2"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="M:JetBrains.Core.Result.Fail(System.String)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/> with <see cref="T:JetBrains.Core.ResultException"/> that wraps provided <see cref="!:message"/>
            </summary>
            <param name="message">Reason of failure. If not defined, <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> is used.</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Fail``1(System.String,``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`2"/> with <see cref="T:JetBrains.Core.ResultException"/> that wraps provided <see cref="!:message"/>
            </summary>
            <param name="message">Reason of failure. If not defined, <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> is used.</param>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.FailWithValue``1(``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/> with message= <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> and user-defined failure parameter 
            </summary>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Canceled">
            <summary>
            Creates special failed <see cref="T:JetBrains.Core.Result`1"/> that wraps <see cref="T:System.OperationCanceledException"/>
            </summary>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false and <see cref="P:JetBrains.Core.Result`1.Canceled"/> == true. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Canceled(System.OperationCanceledException,System.Boolean)">
            <summary>
            Creates special failed <see cref="T:JetBrains.Core.Result`1"/> that wraps <see cref="T:System.OperationCanceledException"/>
            </summary>
            <param name="exception">Captured OCE that lead to this cancellation</param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/>. </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false and <see cref="P:JetBrains.Core.Result`1.Canceled"/> == true. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="F:JetBrains.Core.Result.Unit">
            <summary>
            Void succeed result for <see cref="F:JetBrains.Core.Result.Unit"/> type
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``1(System.Func{``0})">
            <summary>
            Wrap execution of <see cref="!:f"/>() into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Function  to execute</param>
            <typeparam name="TRes">type argument of returned Result</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result`1.Value"/> == f() if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap(System.Action)">
            <summary>
            Wrap execution of <see cref="!:f"/>() into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Action to execute</param>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result.Unit"/> if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``1(System.Action{``0},``0)">
            <summary>
            Wrap execution of <see cref="!:f"/>(<see cref="!:param"/>) into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Action with parameter to execute</param>
            <param name="param">function argument</param>
            <typeparam name="T"><see cref="!:param"/> type</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result.Unit"/> if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>    
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``2(System.Func{``0,``1},``0)">
            <summary>
            Wrap execution of <see cref="!:f"/>(<see cref="!:param"/>) into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Function with parameter to execute</param>
            <param name="param">function argument</param>
            <typeparam name="T"><see cref="!:param"/> type</typeparam>
            <typeparam name="TRes">type argument of returned Result</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result`1.Value"/> == f(param) if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>    
        </member>
        <member name="M:JetBrains.Core.Result.UnwrapTask(JetBrains.Core.Result{System.Threading.Tasks.Task})">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/>.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="T:System.Threading.Tasks.Task"/> in <see cref="F:JetBrains.Core.Result`1.Value"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> and <see cref="T:System.Exception"/>
            </summary>
            <param name="result">this</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that corresponds <see cref="!:result"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.UnwrapTask``1(JetBrains.Core.Result{System.Threading.Tasks.Task{``0}})">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/>.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="T:System.Threading.Tasks.Task"/> in <see cref="F:JetBrains.Core.Result`1.Value"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> and <see cref="T:System.Exception"/>
            </summary>
            <param name="result">this</param>
            <typeparam name="T">type parameter of returning task</typeparam>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that corresponds <see cref="!:result"/></returns>
        </member>
        <member name="T:JetBrains.Core.Result`1">
            <summary>
            Monad that can can have two states: <see cref="P:JetBrains.Core.Result`1.Succeed"/> and Fail (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>). Also we distinct special type of Fail: <see cref="P:JetBrains.Core.Result`1.Canceled"/>.  
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:JetBrains.Core.Result`1.Value">
            <summary>
            Value in case of <see cref="P:JetBrains.Core.Result`1.Succeed"/>, default(T) otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result`1.ExceptionOrExceptionDispatchInfo">
            <summary>
            It this field not null, this Result is !<see cref="P:JetBrains.Core.Result`1.Succeed"/> and vise versa.
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.Exception">
            <summary>
            Exception in case of (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>), null otherwise
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.FailMessage">
            <summary>
            Exception message in case of (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>), null otherwise 
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result`1.#ctor(`0,System.Object)">
            <summary>
            Shouldn't be invoked in user's code
            </summary>
            <param name="success"></param>
            <param name="failure"></param>
        </member>
        <member name="P:JetBrains.Core.Result`1.Succeed">
            <summary>
            !<see cref="P:JetBrains.Core.Result`1.Succeed"/> and <see cref="P:JetBrains.Core.Result`1.Canceled"/>
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.FailedNotCanceled">
            <summary>
            (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>) and (<see cref="P:JetBrains.Core.Result`1.Canceled"/>
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.Canceled">
            <summary>
            Exception has specials type of <see cref="T:System.OperationCanceledException"/> or <see cref="T:System.AggregateException"/> that has <see cref="T:System.OperationCanceledException"/> inside.
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result`1.Map``1(System.Func{`0,``0})">
            <summary>
            Transform this result into new one with given function. if !<see cref="P:JetBrains.Core.Result`1.Succeed"/>, stays untouched./> 
            </summary>
            <param name="transform"></param>
            <typeparam name="TRes"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Core.Result`1.Map``1(``0)">
            <summary>
            Map without lambda. Success{Anything} -> Success{<see cref="!:successValue"/>}. Fail -> Fail
            </summary>
            <param name="successValue">In case of success we always create successful result with this value</param>
            <typeparam name="TRes"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Core.Result`1.Unwrap">
            <summary>
            Returns <see cref="F:JetBrains.Core.Result`1.Value"/> if <see cref="P:JetBrains.Core.Result`1.Succeed"/>, throws <see cref="P:JetBrains.Core.Result`1.Exception"/> otherwise
            </summary>
            <returns> <see cref="F:JetBrains.Core.Result`1.Value"/> if <see cref="P:JetBrains.Core.Result`1.Succeed"/> </returns>
            <exception cref="P:JetBrains.Core.Result`1.Exception">if !<see cref="P:JetBrains.Core.Result`1.Succeed"/></exception>
        </member>
        <member name="M:JetBrains.Core.Result`1.AsCompletedTask">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/> in <see cref="P:System.Threading.Tasks.Task.IsCompleted"/> state state.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="!:Task.IsRanToCompletion"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> with <see cref="P:JetBrains.Core.Result`1.Exception"/>
            </summary>
            <returns><see cref="T:System.Threading.Tasks.Task"/> in <see cref="P:System.Threading.Tasks.Task.IsCompleted"/> state</returns>
        </member>
        <member name="T:JetBrains.Core.Result`2">
            <summary>
            Special kind of <see cref="T:JetBrains.Core.Result`1"/> to store custom <see cref="F:JetBrains.Core.Result`2.FailValue"/> in case of !<see cref="P:JetBrains.Core.Result`2.Succeed"/>. 
            </summary>
            <typeparam name="TSuccess"></typeparam>
            <typeparam name="TFailure"></typeparam>
        </member>
        <member name="F:JetBrains.Core.Result`2.Value">
            <summary>
            Value in case of <see cref="P:JetBrains.Core.Result`2.Succeed"/>, default(T) otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result`2.ExceptionOrExceptionDispatchInfo">
            <summary>
            It this field not null, this Result is !<see cref="P:JetBrains.Core.Result`2.Succeed"/> and vise versa.
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`2.Exception">
            <summary>
            Exception in case of (!<see cref="P:JetBrains.Core.Result`2.Succeed"/>), null otherwise
            </summary>
        </member>
        <member name="T:JetBrains.Core.ResultException">
            <summary>
            Exception arising in <see cref="T:JetBrains.Core.Result"/> when do not specify exception explicitly: <see cref="M:JetBrains.Core.Result.Fail(System.String)"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Core.Unit">
            <summary>
            Type that has the single instance. Adornment to <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Core.Unit.Instance">
            <summary>
            The only way to get instance of type <see cref="T:JetBrains.Core.Unit"/>
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.RName">
            <summary>
            Recursive name. For constructs like Aaaa.Bbb::CCC
            </summary>
        </member>
        <member name="M:JetBrains.Diagnostics.RName.Sub(System.Object,System.String)">
            <summary>
            Separator doesn't count if localName is empty or parent is empty.
            </summary>
            <param name="localName"></param>
            <param name="separator"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:JetBrains.Diagnostics.LogLog">
            <summary>
            To record messages and exceptions from logger (and logger referenced code) and don't fall into infinite recursion.
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LogLog.MaxRecordsToStore">
            <summary>
            Sliding window of records
            </summary>
        </member>
        <member name="P:JetBrains.Diagnostics.LogLog.StoredRecords">
            <summary>
            We store last <see cref="F:JetBrains.Diagnostics.LogLog.MaxRecordsToStore"/> loglog records to browse
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.FirstChanceExceptionInterceptor">
            <summary>
            Facilitates runtime diagnostics when exception arises. In a current thread scope, put diagnostic information in exception if it arises somewhere in call stack.
            All information put will be available with ',' separator under <see cref="F:JetBrains.Diagnostics.FirstChanceExceptionInterceptor.ExceptionDataKey"/> when you print exception
            
            Usage:
            <code>
            using (new FirstChanceExceptionInterceptor.ThreadLocalDebugInfo(your_diagnostic_information))
            {
                you_arbitrary_code
            }
            </code>    
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.OFF">
            <summary>
            Do not use it in logging. Only in config to disable logging.
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.FATAL">
            <summary>
            For errors that lead to application failure 
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.ERROR">
            <summary>
            For errors that must be shown in Exception Browser
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.WARN">
            <summary>
            Suspicious situations but not errors
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.INFO">
            <summary>
            Regular level for important events
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE">
            <summary>
            Additional info for debbuging
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.TRACE">
            <summary>
            Methods &amp; callstacks tracing, more than verbose
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.OuterLifetime">
            <summary>
              <para>A subset of the <see cref="T:JetBrains.Lifetimes.Lifetime" /> interface with which you cannot “bind” actions to a lifetime.</para>
              <para>It's “outer” in the sense that it's not your lifetime, but of some parent object potentially more long-lived than yours. You cannot schedule anything to its termination because it will happen way after your object goes off scope.</para>
              <para>The only thing you can know is that it's an “outer”, it's limiting the life of your object, and if it's terminated — so are you. Checking for <see cref="P:JetBrains.Lifetimes.OuterLifetime.IsTerminated" /> is one of the allowed option.</para>
              <para>Another option is to define a nested lifetime, in which case you MUST ensure it's terminated explicitly, without relying on the outer lifetime. The outer lifetime is only a safety catch to make sure it does not live too long.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.OuterLifetime.IsTerminated">
            <summary>
              <para>Gets whether this lifetime has already been terminated.</para>
              <para>It's an error to continue scheduling on a terminated lifetime.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.UsingNestedAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.UsingNestedAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.Define(JetBrains.Lifetimes.OuterLifetime,System.String,System.Action{JetBrains.Lifetimes.LifetimeDefinition,JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>See documentation on an overload which takes a <see cref="T:JetBrains.Lifetimes.Lifetime" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.DefineIntersection(JetBrains.Lifetimes.OuterLifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.Eternal">
            <summary>
            <para>A lifetime that never ends. Scheduling actions on such a lifetime has no effect.</para>
            <para>Do not call <see cref="M:JetBrains.Lifetimes.Lifetime.AddRef(System.Object)"/> on such a lifetime, because it will not hold your object forever.</para>  
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Using``1(System.Func{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNested(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent  lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNested``1(System.Func{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent  lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync(JetBrains.Lifetimes.OuterLifetime,System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="parent">A parent lifetime which limits the lifetime given to your action, and migth terminate it before the action ends.</param>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync``1(JetBrains.Lifetimes.OuterLifetime,System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="parent">A parent lifetime which limits the lifetime given to your action, and migth terminate it before the action ends.</param>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNestedAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNestedAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Synchronize(JetBrains.Lifetimes.LifetimeDefinition[])">
            <summary>
            Synchronizes termination of two lifetime definitions.
            Whenever any one is terminated, the other will be terminated also.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates an intersection with other lifetime — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime,JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.DefineIntersection(JetBrains.Lifetimes.Lifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Define(JetBrains.Lifetimes.Lifetime,System.String,System.Action{JetBrains.Lifetimes.LifetimeDefinition})">
            <summary>
              <para>Defines a new lifetime nested within the <paramref name="lifetime" /> you pass in.</para>
            </summary>
            <remarks>
              <para>In most cases, you should have some lifetime to use as a parent, such as the lifetime of your component. If this is not the case, and you just need a function-scoped lifetime, call <see cref="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})" /> instead. It is terminated automatically when your action ends and thus does not need a parent.</para>
              <para>If the lifetime you're created is really not parented by any other lifetime, use the <see cref="P:JetBrains.Lifetimes.Lifetime.Eternal" /> as a parent.</para>
            </remarks>
            <param name="lifetime">
              <para>The parent lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </param>
            <param name="id">
              <para>Optional. The ID of the lifetime.</para>
              <para>Used for tracking and debugging. If the call stack annotations feature is ON, this ID will appear on the call stack when the lifetime object starts executing scheduled actions upon termination.</para>
              <para>In case of nested lifetimes and if scheduled actions are anonymous in their nature, it might be hard to tell what's happening from exception stack traces without this annotation. You're encouraged to specify IDs wherever such situations are suspected, but the IDs should better be statically defined (to avoid memory leaks on part of the call stacks annotation engine).</para>
              <para>If omitted, the default <see cref="F:JetBrains.Lifetimes.LifetimeDefinition.AnonymousLifetimeId" /> or the <see cref="T:JetBrains.Lifetimes.Lifetime" /> should type name is used, depending on the context.</para>
            </param>
            <param name="atomicAction">
              <para>Optional. The code to be executed atomically on the newly-created lifetime.</para>
              <para>If this code succeeds (or is not specified), the definition of the new lifetime is returned from the method.</para>
              <para>If this code fails with an exception, the newly-created lifetime is terminated, all of the scheduled actions are executed (rolling back any activities already bound to the lifetime), the nested lifetime is not registered no the parent, and the exception is let out of this method.</para>
            </param>    
            <returns>
              <para>The definition to the new lifetime.</para>
              <para>As you own the lifetime, you can terminate it through this definition at any time.</para>
              <para>To pass the lifetime to objects&amp;functions or schedule termination actions on it, get it from the <see cref="P:JetBrains.Lifetimes.LifetimeDefinition.Lifetime" /> property. Do not pass the definition itself to child objects, unless this is the intended scenario to allow them to terminate the lifetime upon their discretion (e. g. a user-cancelable non-modal dialog).</para>
            </returns>
            <seealso cref="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})" />
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.AssertEverTerminated(System.String)">
            <summary>
            <para>If this lifetime never gets terminated (and all the references to it get lost), reports an exception to the logger.</para>
            <para>The lifetime will not be terminated automatically, because this is not a lifetime definition. See Remarks for options.</para>
            <para>Note that this method means certain load on the finalization queue, and can degrade performance if used in large amounts.</para>
            <para>Fluent.</para>
            </summary>
            <remarks>
            <para>As this method operates on a <see cref="T:JetBrains.Lifetimes.Lifetime"/> object you do not own, it cannot terminate the lifetime automatically when a missed termination is detected.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.AssertTerminatesIn(System.TimeSpan,System.String)">
            <summary>
            Log error if this lifetime hasn't been terminated in specified <paramref name="timeout"/> 
            </summary>
            <param name="timeout">Maximum timeout to wait this lifetime is terminated</param>
            <param name="comment">Optional comment to log when assertion failed</param>
        </member>
        <member name="T:JetBrains.Lifetimes.SequentialLifetimes">
            <summary>
            Maintains a sequence of lifetimes, so that the previous lifetime is closed before the new one is opened.
            Good for implementing a sequence of non-simultaneous activities when it's nice to guarantee only one is active at a time.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.#ctor(JetBrains.Lifetimes.Lifetime)">
            <summary>Creates and binds to the lifetime.</summary>
            <param name="lifetime">When this lifetime is closed, the last of the sequential lifetimes is closed too.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.Next(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.TerminateCurrent">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            The lifetime definition allows to terminate it as desired.
            Also, the lifetime will be terminated when either parent lifetime is terminated,
            or <see cref="M:JetBrains.Lifetimes.SequentialLifetimes.TerminateCurrent"/> is called, or <see cref="M:JetBrains.Lifetimes.SequentialLifetimes.DefineNext(System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>/<see cref="M:JetBrains.Lifetimes.SequentialLifetimes.Next"/> is called.
            </summary>
            <summary>
            Terminates the current lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.SetNextAndTerminateCurrent(JetBrains.Lifetimes.LifetimeDefinition)">
            <summary>
            Atomically, assigns the new lifetime and terminates the old one.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.SpinWaitEx">
            <summary>
            Extensions for <see cref="T:System.Threading.SpinWait"/> static methods.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(JetBrains.Lifetimes.Lifetime,System.TimeSpan,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="lifetime"/> is alive, <paramref name="timeout"/> is not elapsed and <paramref name="condition"/> is false.     
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeout">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeout"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(JetBrains.Lifetimes.Lifetime,System.Int64,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="lifetime"/> is alive, <paramref name="timeoutMs"/> is not elapsed and <paramref name="condition"/> is false.     
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeoutMs">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeoutMs"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>    
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntilAsync(JetBrains.Lifetimes.Lifetime,System.Int64,System.Int32,System.Func{System.Boolean})">
            <summary>
            Spins in ASYNC manner (not consuming thread or CPU resources) while <paramref name="lifetime"/> is alive, <paramref name="timeoutMs"/> is not elapsed and <paramref name="condition"/> is false.
            Sleeps in async fashion (using <see cref="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)"/> for <paramref name="delayBetweenChecksMs"/> each time between <paramref name="condition"/> check.
            Only <paramref name="lifetime"/> cancellation could immediately return execution from delay. 
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeoutMs">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="delayBetweenChecksMs">Interval to delay</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeoutMs"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns> 
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Start">
            <summary>
            Starts async processing of queue.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Stop(System.Int32)">
            <summary>
            Graceful stop. Process queue, but doesn't accept new data via <see cref="M:JetBrains.Threading.ByteBufferAsyncProcessor.Put(System.Byte[])"/>. Joins processing thread for given timeout. If timeout elapsed, aborts thread.
            </summary>
            <param name="timeoutMs">Timeout to wait. <see cref="F:System.Threading.Timeout.Infinite"/> for infinite waiting.</param>
            <returns>'true' if Join(timeoutMs) was successful, false otherwise. Also returns 'false' if thread is already stopped or killed."></returns>
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Terminate(System.Int32)">
            <summary>
            Force stop. Doesn't process queue, doesn't accept new data via <see cref="M:JetBrains.Threading.ByteBufferAsyncProcessor.Put(System.Byte[])"/>. Joins processing thread for given timeout. If timeout elapsed, aborts thread.
            </summary>
            <param name="timeoutMs">Timeout to wait. <see cref="F:System.Threading.Timeout.Infinite"/> for infinite waiting.</param>
            <returns>'true' if Join(timeoutMs) was successful, false otherwise. Also returns 'false' if thread is already stopped or killed."></returns>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeReader.ReadCollection``2(JetBrains.Serialization.UnsafeReader.ReadDelegate{``0},System.Func{System.Int32,``1})">
            <summary>
            Non optimal collection serialization. One can serialize internal structure (eg. array) instead.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCol"></typeparam>
            <param name="readDelegate"></param>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Cookie.WriteIntLengthToCookieStart">
            <summary>
            Writes `<see cref="P:JetBrains.Serialization.UnsafeWriter.Cookie.Count"/><c> - sizeof(int)</c>` into the <see cref="P:JetBrains.Serialization.UnsafeWriter.Cookie.Data"/> pointer. Cookie must be prepared by invoking `<see cref="M:JetBrains.Serialization.UnsafeWriter.Write(System.Int32)"/><c>(0)</c>` as first cookie call.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.WriteStringContent(System.String)">
            <summary>
            Doesn't write length prefix, only string contents. If value == null, does nothing.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.WriteStringContent(System.String,System.Int32,System.Int32)">
            <summary>
            Doesn't write length prefix, only string contents. If value == null, does nothing.
            </summary>
            <param name="value"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)">
            <summary>
            Correctly allocates the number of bytes as if they were written with any func, and advances the pointer past them.
            This is useful if you want to use buffer space for direct memory access.
            Take the <see cref="P:JetBrains.Serialization.UnsafeWriter.Ptr" /> value before calling <see cref="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)" /> to address the space correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Write``2(JetBrains.Serialization.UnsafeWriter.WriteDelegate{``0},``1)">
            <summary>
            Non optimal collection serialization. You can serialize internal structure (eg. array) instead.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.WriteCollection``2(System.Collections.Generic.ICollection{``0},``1,JetBrains.Serialization.UnsafeWriter.WriteDelegate{``0,``1})">
            <summary>
            Non optimal collection serialization. You can serialize internal structure (eg. array) instead.
            </summary>
        </member>
    </members>
</doc>
